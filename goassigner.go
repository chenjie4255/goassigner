package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func main() {
	inputFile := ""
	flag.StringVar(&inputFile, "f", "", "output file")
	flag.Parse()

	objs, err := parseFile(inputFile)
	if err != nil {
		fmt.Printf("parse file error:%s", err)
		return
	}

	fmt.Printf("parse result:%+v", objs)
	outputPath := getOutputPath(inputFile)
	render(outputPath, "example", objs)
}

func getOutputPath(inputPath string) string {
	if !strings.HasSuffix(inputPath, ".go") {
		return ""
	}
	dir, file := filepath.Split(inputPath[:len(inputPath)-3])
	return filepath.Join(dir, fmt.Sprintf("%s_assigner.go", file))
}

// type renderObjectField struct {
// 	Name   string
// 	Prefix []string
// }

// type renderObject struct {
// 	TopStructType string
// 	Fields        []renderObjectField
// 	LinkPackage   string
// 	LinkObject    string
// }

// type RenderData struct {
// 	Package     string
// 	ImportPaths []string
// 	Objects     []renderObject
// }

var renderTemplate = template.Must(template.New("render").Parse(`// This file is generated by goassigner, DO NOT EDIT IT.
// see (github.com/chenjie4255/goassigner) 
package {{.Package}}
import ({{range .ImportPaths}}
"{{.}}"{{end}}
)

{{range .Objects}}
func (s *{{.TopStructType}})assign{{range .FieldPrefix}}{{.}}{{end}}(src {{if .LinkPackage}}{{.LinkPackage}}.{{end}}{{.LinkObject}}) {
	{{range .Fields}}s.{{range .Prefix}}{{.}}.{{end}}{{.Name}} = src.{{.Name}}
	{{end}}
}
{{ $length := len .FieldPrefix }} {{ if eq $length 0 }}
func assign{{.TopStructType}}Array(dest *[]{{.TopStructType}}, src []{{if .LinkPackage}}{{.LinkPackage}}.{{end}}{{.LinkObject}}) {
	*dest = make([]{{.TopStructType}}, len(src))
	for i, so := range src {
		{{range .Fields}}(*dest)[i].{{range .Prefix}}{{.}}.{{end}}{{.Name}} = so.{{.Name}} 
		{{end}}
	}
}
{{end}}{{end}}
`))

func render(outputPath, packageName string, objs []assignObject) {

	type renderObjectField struct {
		Name   string
		Prefix []string
	}

	type renderObject struct {
		TopStructType string
		FieldPrefix   []string
		Fields        []renderObjectField
		LinkPackage   string
		LinkObject    string
	}

	type RenderData struct {
		Package     string
		ImportPaths []string
		Objects     []renderObject
	}

	output, err := os.OpenFile(outputPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("create/open output file(%s) fail: %s", outputPath, err)
		return
	}
	defer output.Close()

	var data RenderData
	data.Package = packageName

	for _, o := range objs {
		renderObj := renderObject{}
		renderObj.LinkObject = o.LinkObject
		renderObj.TopStructType = o.TopStructType
		renderObj.LinkPackage = o.LinkPackage
		renderObj.FieldPrefix = o.FieldPrefix

		for _, f := range o.Fields {
			field := renderObjectField{}
			field.Name = f
			field.Prefix = o.FieldPrefix

			renderObj.Fields = append(renderObj.Fields, field)
		}
		data.Objects = append(data.Objects, renderObj)
	}

	for k := range importPath {
		data.ImportPaths = append(data.ImportPaths, k)
	}

	renderTemplate.Execute(output, data)

}

const (
	parseReg = `@goassigner:([A-Z][a-z0-9A-Z]+)[:]{0,1}([A-Za-z0-9/-_.]*)`
)

func parseAssignerComment(text string) (linkName, linkPackagePath string) {
	reg := regexp.MustCompile(parseReg)
	result := reg.FindStringSubmatch(text)
	if len(result) == 3 {
		linkName = result[1]
		linkPackagePath = result[2]
	}

	return
}
